# 说明文档（开发者版）

本文档是对于开发者的，主要包含一些规定。

## 设计风格

设计时，需遵守以下设计风格（参考自《现代编译原理》，有修改）

### 树结构风格：

1.树都用文法来表示

2.一棵树用一至多个`typedef`来描述，每个`typedef`对应文法中的一个符号

3.每个`typedef`定义一个指向相应`struct`的指针。这个`struct`的名字以下划线结束，它除了在`typedef`的声明和该结构定义本身出现外，决不会在其他地方使用

4.每个`struct`有一个kind域和一个u域。kind是一个指明不同选择的`enum`，每个枚举值对应一个可选的文法规则；u是一个`union`。

5.如果一个规则的右部有多个非平凡（即携带有值的符号）（例如规则Compound-Stm），则它的`union`有一个本身也是结构的成员给出组成它的这些值（例如，A_stm_（`union`）中的成员compound）

6.如果一个规则的右部只有一个非平凡的符号，则它的`union`有一个就是其值的成员（例如A_exp(`union`)中的成员num）

7.每个类中有一个对所有成员进行初始化的构造函数。除了在这些构造函数中，其他地方绝不会直接调用malloc函数。

8.每一个模块（头文件）有一个唯一标识该模块的前缀（例如A_）

9.类型定义名（位于前缀之后的）应用小写字母开头，构造函数名（位于前缀之后）用大写字母开头，`union`的成员（没有前缀）用小写字母开头

### 模块化规则（C语言部分）

1.编译器的每个阶段或者模块都应该归入各自的".c"文件，且该文件有对应的".h"文件。

2.每个模块都应有该模块唯一的前缀。由此模块导出的所有全局名字（注意：`struct`和`union`的成员名字不是全局的）都应以此前缀打头。这样，文件的阅读者就不必通过到文件之外去查找一个名字的来源。

3.所有函数都应有函数原型；如果使用了没有原型的函数，C编译器将给出警告信息。

4.我们将在每一个文件中用`#include "util.h"`以包含`util.h`

```c
/*util.h*/
#include <assert.h>

typedef char *string;
string String(char *);

typedef char bool;

#define TRUE 1
#define FALSE 0

void *checked_malloc(int);
```

鼓励多使用断言。

5.string类型表示分配在堆中的字符串，这种字符串在初次创建后便不会再改变。函数String从C风格的字符指针来创建一个分配在堆中的字符串string（类似标准C库函数的`strdup`）。那些以string作为参数的函数都假定这些参数的内容决不会改变。

6.C的`malloc`函数在无内存空间可分配是会返回`NULL`，为了避免复杂的内存管理，所以只调用自己的函数`checked_malloc`，这个函数保证不会返回`NULL`。
```c
void *checked_malloc(int len) {
    void *p = malloc(len);
    assert(p);  //If p is NULL, return error
    return p;
}
```

7.在`Testing`版本时，C程序暂时允许不调用`free`释放内存（哪怕产生内存泄露）。在其他版本当中，应该在合适的时候进行`free`或者采用垃圾收集的方式。

### Lex风格
1.在正则表达式部分，匹配部分后空一格，用大括号包含语句，风格类似下面这样：
```lex
if {
    ADJ;
    return IF;
}
```

2.所有标识符（TOKEN）返回的都应该是大写字母。